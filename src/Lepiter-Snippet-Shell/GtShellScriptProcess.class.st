"
I am GtShellScriptProcess.

I represent a Shell script to be executed by /bin/sh on a Unix system (macOS or Linux).

When I run, I am executing asynchronously, updating myself when necessary. 
"
Class {
	#name : #GtShellScriptProcess,
	#superclass : #Object,
	#instVars : [
		'script',
		'childProcess',
		'stdout',
		'stderr',
		'poller',
		'announcer',
		'state'
	],
	#category : #'Lepiter-Snippet-Shell'
}

{ #category : #private }
GtShellScriptProcess >> announce: announcement [
	self announcer announce: announcement
]

{ #category : #accessing }
GtShellScriptProcess >> announcer [
	^ announcer
]

{ #category : #testing }
GtShellScriptProcess >> didRun [
	^ state = #ran
]

{ #category : #examples }
GtShellScriptProcess >> example10stepsOf1Second [
	<gtExample>
	self script: 
'for ((i = 0 ; i < 10 ; i++)); do
  echo `date` @ $i
  sleep 1
done
echo `date` done'
]

{ #category : #examples }
GtShellScriptProcess >> exampleEmpty [
	<gtExample>
	self assert: self isRunning not.
	self assert: self didRun not
]

{ #category : #examples }
GtShellScriptProcess >> exampleFailure [
	<gtExample>
	self script: 'echo Something went wrong >&2
exit 1'
]

{ #category : #examples }
GtShellScriptProcess >> exampleListWorkingDirectory [
	<gtExample>
	self script: 'ls -1'
]

{ #category : #examples }
GtShellScriptProcess >> examplePrintWorkingDirectory [
	<gtExample>
	self script: 'pwd'
]

{ #category : #examples }
GtShellScriptProcess >> exampleStdoutVsStderr [
	<gtExample>
	self script: 'echo 2001: A Space Odyssey
echo "I can''t do that, Dave" >&2'
]

{ #category : #private }
GtShellScriptProcess >> execute [
	| builder |
	
	builder := GtExternalProcessBuilder new
		command: '/bin/sh';
		arg: '-c';
		arg: (String lf join: self script lines).
			
	childProcess := builder
		pipeStdout;
		pipeStderr;
		spawn.

	childProcess asynchronousStdout
		pollStringEvery: 0.5 seconds
		do: [ :aString | stdout show: aString ].

	childProcess asynchronousStderr
		pollStringEvery: 0.5 seconds
		do: [ :aString | stderr show: aString ].

	poller := [ 
		[ childProcess isRunning ] whileTrue: [ 0.5 seconds wait ].
		state := #ran.
		self announce: GtShellScriptStopped ] 
		forkAt: Processor userBackgroundPriority named: 'poller'.
]

{ #category : #'gt extensions' }
GtShellScriptProcess >> gtStartActionFor: composite [
	<gtAction>
	^ composite button
		icon: BrGlamorousVectorIcons play;
		tooltip: 'Start';
		priority: 20;
		action: [ self start ]
]

{ #category : #'gt extensions' }
GtShellScriptProcess >> gtStopActionFor: composite [
	<gtAction>
	^ composite button
		icon: BrGlamorousVectorIcons stop;
		tooltip: 'Stop';
		priority: 30;
		action: [ self stop ]
]

{ #category : #'gt extensions' }
GtShellScriptProcess >> gtViewScriptFor: composite [
	<gtView>
	self hasScript ifFalse: [ ^ composite empty ].
	^ composite text
		title: 'Script';
		priority: 20;
		text: [ self script ]
]

{ #category : #'gt extensions' }
GtShellScriptProcess >> gtViewStateFor: composite [
	<gtView>
	^ composite text
		title: 'State';
		priority: 10;
		text: [ self stateDescription ];
		updateWhen: GtShellScriptAnnouncement in: [ self announcer];
		actionUpdateButton
]

{ #category : #'gt extensions' }
GtShellScriptProcess >> gtViewStderrFor: composite [
	<gtView>
	stderr ifNil: [ ^ composite empty ].
	^ composite forward
		title: 'Stderr';
		priority: 35;
		object: [ stderr ];
		view: #gtLiveFor:;
		actionUpdateButton
]

{ #category : #'gt extensions' }
GtShellScriptProcess >> gtViewStdoutFor: composite [
	<gtView>
	stdout ifNil: [ ^ composite empty ].
	^ composite forward
		title: 'Stdout';
		priority: 30;
		object: [ stdout ];
		view: #gtLiveFor:;
		actionUpdateButton
]

{ #category : #testing }
GtShellScriptProcess >> hasScript [
	^ script isEmptyOrNil not
]

{ #category : #initialization }
GtShellScriptProcess >> initialize [
	super initialize.
	announcer := Announcer new.
	state := #new.
	stdout := GtTranscript new.
	stderr := GtTranscript new.
]

{ #category : #testing }
GtShellScriptProcess >> isFailure [
	^ self didRun
		and: [ childProcess isTerminated and: [ childProcess wait isSuccess not ] ]
]

{ #category : #testing }
GtShellScriptProcess >> isRunning [
	^ state = #running
]

{ #category : #testing }
GtShellScriptProcess >> isSuccess [
	^ self didRun
		and: [ childProcess isTerminated and: [ childProcess wait isSuccess ] ]
]

{ #category : #accessing }
GtShellScriptProcess >> output [
	stdout textDo: [ :text | ^ text asString trimBoth ].
	^ String new
]

{ #category : #accessing }
GtShellScriptProcess >> script [
	^ script
]

{ #category : #accessing }
GtShellScriptProcess >> script: aString [
	script := aString
]

{ #category : #running }
GtShellScriptProcess >> start [
	self isRunning ifTrue: [ ^ self ].
	self hasScript ifFalse: [ ^ self ].
	self execute.
	state := #running.
	self announce: GtShellScriptStarted
]

{ #category : #accessing }
GtShellScriptProcess >> state [
	^ state
]

{ #category : #accessing }
GtShellScriptProcess >> stateDescription [
	| description |
	description := self state.
	self isSuccess
		ifTrue: [ description := description , ' successfully' ].
	self isFailure
		ifTrue: [ description := description , ' and failed' ].
	^ description
]

{ #category : #running }
GtShellScriptProcess >> stop [
	self isRunning ifFalse: [ ^ self ].
	poller terminate.
	childProcess terminate.
	state := #terminated.
	self announce: GtShellScriptStopped
]
